<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Reflector Client</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #0a0a0a; color: #fff; }
        .header { position: fixed; top: 0; width: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); 
                 padding: 10px 20px; z-index: 1000; display: flex; justify-content: space-between; align-items: center; }
        .title { font-size: 18px; font-weight: 600; }
        .stats { font-size: 12px; opacity: 0.7; text-align: right; }
        .shadow-container { margin-top: 60px; padding: 20px; background: #111; border-radius: 8px; 
                           box-shadow: 0 4px 20px rgba(0,0,0,0.5); min-height: calc(100vh - 80px); }
        .log { position: fixed; bottom: 10px; left: 10px; font-size: 11px; opacity: 0.6; }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">ðŸ”„ Reflector Client</div>
        <div class="stats" id="stats">Connecting...</div>
    </div>
    <div class="shadow-container" id="content">
        <p>Waiting for host connection...</p>
    </div>
    <div class="log" id="log">Initializing...</div>

    <script>
        const reflector = {
            key: 'test-broadcast-123',
            endpoint: 'http://172.20.230.22:4242/reflector',
            enabled: true,
            pollInterval: 10000
        };

        const reflectorClient = {
            pc: null,
            connected: false,
            currentOfferSdp: null,  // Track current offer SDP
            answerSent: false,
            sessionId: 0,
            stats: { received: 0, lastUpdate: 0 },
            
            async init() {
                this.sessionId++;
                this.log(`Starting client session ${this.sessionId}`);
                
                this.pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.iptel.org' }]
                });
                
                this.pc.ondatachannel = e => {
                    const channel = e.channel;
                    channel.onopen = () => {
                        this.connected = true;
                        this.log('ðŸ“¡ Connected to host');
                    };
                    channel.onmessage = e => this.handleMessage(JSON.parse(e.data));
                    channel.onclose = () => {
                        this.connected = false;
                        this.answerSent = false;
                        this.currentOfferSdp = null;
                        this.log('âš¡ Connection lost, reconnecting...');
                        setTimeout(() => this.init(), 2000);
                    };
                };
                
                this.pc.onicecandidate = e => e.candidate && this.sendSignal({
                    type: 'ice', candidate: e.candidate
                });
                
                // Add connection state monitoring with ICE restart handling
                this.pc.onconnectionstatechange = () => {
                    this.log(`Connection state: ${this.pc.connectionState}`);
                    if (this.pc.connectionState === 'failed') {
                        this.log('Connection failed, waiting for ICE restart...');
                        // Don't immediately restart - wait for host's ICE restart
                        setTimeout(() => {
                            if (!this.connected) {
                                this.log('No ICE restart received, doing full restart...');
                                this.init();
                            }
                        }, 5000);
                    } else if (this.pc.connectionState === 'connected') {
                        this.log('Connection restored!');
                    }
                };
                this.pc.oniceconnectionstatechange = () => {
                    this.log(`ICE connection state: ${this.pc.iceConnectionState}`);
                    if (this.pc.iceConnectionState === 'disconnected') {
                        this.log('ICE disconnected, waiting for reconnection...');
                    }
                };
                
                this.pollForOffer();
                this.updateStats();
            },
            
            async pollForOffer() {
                if (this.connected) return;
                
                try {
                    const response = await fetch(`${reflector.endpoint}?key=${reflector.key}`, {
                        headers: { 'User-Agent': navigator.userAgent }
                    });
                    const data = await response.json();
                    
                    if (data?.offer?.type === 'offer') {
                        // Check if this is a new offer or if we need to resume
                        const isNewOffer = data.offer.sdp !== this.currentOfferSdp;
                        const hasExistingAnswer = data.answer?.type === 'answer';
                        
                        if (isNewOffer || !this.answerSent) {
                            this.currentOfferSdp = data.offer.sdp;
                            
                            if (hasExistingAnswer && !this.answerSent) {
                                // Resume existing session - use server's answer
                                this.log('ðŸ“¨ Resuming existing session...');
                                await this.pc.setRemoteDescription(data.offer);
                                await this.pc.setLocalDescription(data.answer);
                                this.answerSent = true;
                            } else if (!hasExistingAnswer) {
                                // New offer - create fresh answer
                                this.log('ðŸ“¨ New offer received, sending answer...');
                                await this.pc.setRemoteDescription(data.offer);
                                const answer = await this.pc.createAnswer();
                                await this.pc.setLocalDescription(answer);
                                await this.sendSignal({ type: 'answer', sdp: answer.sdp });
                                this.answerSent = true;
                            }
                            
                            this.log('ðŸ“© Processing ICE candidates...');
                            // Process any pending ICE candidates from host
                            if (data.ice && data.ice.length > 0) {
                                for (const iceData of data.ice) {
                                    if (iceData.candidate) {
                                        await this.pc.addIceCandidate(iceData.candidate);
                                    }
                                }
                            }
                        }
                    } else {
                        setTimeout(() => this.pollForOffer(), 5000);  // Slower polling
                        this.log('Polling for offer...');
                    }
                } catch (e) {
                    this.log(`Error: ${e.message}`);
                    setTimeout(() => this.pollForOffer(), 10000);  // Much slower on error
                }
            },
            
            async sendSignal(data) {
                await fetch(`${reflector.endpoint}?key=${reflector.key}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
            },
            
            handleMessage(data) {
                this.stats.received++;
                this.stats.lastUpdate = data.timestamp;
                document.getElementById('content').innerHTML = data.body;
                document.title = data.title;
            },
            
            updateStats() {
                const el = document.getElementById('stats');
                const uptime = Math.floor((Date.now() - performance.timeOrigin) / 1000);
                const lastUpdate = this.stats.lastUpdate ? 
                    Math.floor((Date.now() - this.stats.lastUpdate) / 1000) : 'âˆž';
                
                el.innerHTML = `
                    Status: ${this.connected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'}<br>
                    Received: ${this.stats.received}<br>
                    Last: ${lastUpdate}s ago<br>
                    Uptime: ${uptime}s
                `;
                setTimeout(() => this.updateStats(), 1000);
            },
            
            log(msg) {
                document.getElementById('log').textContent = msg;
                console.log(msg);
            }
        };

        reflectorClient.init();
    </script>
</body>
</html>